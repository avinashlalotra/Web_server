# Compiler Drivers
we might invoke the gcc driver by typing the following command to the shell:
```
linux> gcc -Og -o prog main.c sum.c
```
The driver first runs
the C preprocessor (cpp),1 which translates the C source file main.c into an ASCII
intermediate file main.i:

C preprocessor ( cpp )
```
cpp  main.c /tmp/main.i
```
Next, the driver runs the C compiler (cc1), which translates main.i into an ASCII
assembly-language file main.s:
```
gcc  -S /tmp/main.i  -o /tmp/main.s
```
Then, the driver runs the assembler (as), which translates main.s into a binary
relocatable object file main.o:
```
as -o /tmp/main.o /tmp/main.s
```
The driver goes through the same process to generate sum.o. Finally, it runs the
linker program ld, which combines main.o and sum.o, along with the necessary
system object files, to create the binary executable object file prog:
```
ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o
```
Use 
```gcc -o prog main.o sum.o ```
 which will automatically link the files.

# Static Linking
Static linkers such as the Linux ld program take as input a collection of relocatable
object files and command-line arguments and generate as output a fully linked
executable object file that can be loaded and run.

To build the executable, the linker must perform two main tasks:

- `Step 1.` Symbol resolution. Object files define and reference symbols, where each
symbol corresponds to a function, a global variable, or a static variable
(i.e., any C variable declared with the static attribute). The purpose of
symbol resolution is to associate each symbol reference with exactly one
symbol definition.

- `Step 2.` Relocation. Compilers and assemblers generate code and data sections
that start at address 0. The linker relocates these sections by associating a
memory location with each symbol definition, and then modifying all of
the references to those symbols so that they point to this memory location.
The linker blindly performs these relocations using detailed instructions,
generated by the assembler, called relocation entries.

# Object Files
Object files come in three forms:

- `Relocatable object file.` Contains binary code and data in a form that can be
combined with other relocatable object files at compile time to create an
executable object file.
- `Executable object file.` Contains binary code and data in a form that can be
copied directly into memory and executed.
- `Shared object file.` A special type of relocatable object file that can be loaded
into memory and linked dynamically, at either load time or run time.

# Relocatable Object Files
The ELF
header begins with a 16-byte sequence that describes the word size and byte
ordering of the system that generated the file. The rest of the ELF header contains
information that allows a linker to parse and interpret the object file.

- `.text `The machine code of the compiled program.
`.rodata` Read-only data such as the format strings in printf statements, and
jump tables for switch statements.
- `.data` Initialized global and static C variables. Local C variables are maintained
at run time on the stack and do not appear in either the .data or .bss
sections.
- `.bss` Uninitialized global and static C variables, along with any global or static
variables that are initialized to zero. This section occupies no actual space
in the object file; it is merely a placeholder. Object file formats distinguish
between initialized and uninitialized variables for space efficiency: unini-
tialized variables do not have to occupy any actual disk space in the object
file. At run time, these variables are allocated in memory with an initial
value of zero.

```
The use of the term .bss to denote uninitialized data is universal. It was originally an acronym for the
“block started by symbol” directive from the IBM 704 assembly language (circa 1957) and the acronym
has stuck. A simple way to remember the difference between the .data and .bss sections is to think
of “bss” as an abbreviation for “Better Save Space!”
```

- `.symtab` A symbol table with information about functions and global variables
that are defined and referenced in the program. Some programmers mis-
takenly believe that a program must be compiled with the -g option to
get symbol table information. In fact, every relocatable object file has
a symbol table in .symtab (unless the programmer has specifically re-
moved it with the strip command). However, unlike the symbol table
inside a compiler, the .symtab symbol table does not contain entries for
local variables.
- `.rel.text` A list of locations in the .text section that will need to be modified
when the linker combines this object file with others. In general, any
instruction that calls an external function or references a global variable
will need to be modified. On the other hand, instructions that call local
functions do not need to be modified. Note that relocation information
is not needed in executable object files, and is usually omitted unless the
user explicitly instructs the linker to include it.
- `.rel.data` Relocation information for any global variables that are referenced
or defined by the module. In general, any initialized global variable whose
initial value is the address of a global variable or externally defined func-
tion will need to be modified.
- `.debug` A debugging symbol table with entries for local variables and typedefs
defined in the program, global variables defined and referenced in the
program, and the original C source file. It is only present if the compiler
driver is invoked with the -g option.
- `.line` A mapping between line numbers in the original C source program and
machine code instructions in the .text section. It is only present if the
compiler driver is invoked with the -g option.
- `.strtab` A string table for the symbol tables in the .symtab and .debug sec-
tions and for the section names in the section headers. A string table is a
sequence of null-terminated character strings.

# Symbols and Symbol Tables

Each relocatable object module, m, has a symbol table that contains information
about the symbols that are defined and referenced by m. In the context of a linker,
there are three different kinds of symbols:

- `Global symbols` that are defined by module m and that can be referenced by
other modules. Global linker symbols correspond to nonstatic C functions and
global variables.

- `Global symbols` that are referenced by module m but defined by some other
module. Such symbols are called externals and correspond to nonstatic C
functions and global variables that are defined in other modules.

- `Local symbols` that are defined and referenced exclusively by module m. These
correspond to static C functions and global variables that are defined with the
static attribute. These symbols are visible anywhere within module m, but
cannot be referenced by other modules.